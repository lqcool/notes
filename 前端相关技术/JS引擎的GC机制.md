### javaScript垃圾回收小记

文章参考：https://segmentfault.com/a/1190000015641168

参考网址：https://javascript.info/garbage-collection

#### 变量的可触及和不可触及

javascript中内存管理设计到的概念有可触及和不可触及，什么是可触及和不可触及呢？简单的讲：

- **可触及**：就是可以访问的，可用的，这些值被安全的存储在内存
- **不可触及**：就是不可访问到的，不可用的，这些值会在某个时候被回收

（1）有如下的一些必定是“可触及”的值，不管有任何原因，都不能够删除（这些值叫做`roots`）

- 当前函数的局部变量和参数
- 当前调用链中的所有函数的局部变量和参数
- 全局变量
- 其它内部变量（内置的变量）

（2）其它的值是否可以触及在于他们是否被root和其引用链引用。

For instance, if there’s an object in a local variable, and that object has a property referencing another object, that object is considered reachable. And those that it references are also reachable. Detailed examples to follow. 

#### 垃圾清除算法之标记清除原理和过程

常用的垃圾回收算法有标记清除和引用计数，引用技术常常会有循环引用的问题。

- 标记清除：一种基础的垃圾回收算法（标记-清除算法），算法的过程如下

  - 垃圾回收器获取并标记 root
  - 然后访问并标记来自他们的所有引用 
  - 访问被标记的对象，标记*他们的*引用。所有被访问过的对象都会被记录，以后将不会重复访问同一对象 
  - ……直到只剩下未访问的引用 
  - 所有未被标记的对象都会被移除 

  首先假设有如下对象结构：在这个对象结构中，很明显的看到有一个孤岛（Unreachable island），使用标记清除它的过程如下：

  ![1534251164256](C:\Users\AbnerLi\AppData\Local\Temp\1534251164256.png)

  - 标记root

  ![1534251310633](C:\Users\AbnerLi\AppData\Local\Temp\1534251310633.png)

  - 然后标记root的们的引用对象

  ![1534251352082](C:\Users\AbnerLi\AppData\Local\Temp\1534251352082.png)

  - 标记他们引用的引用（这个过程知道遍历完成所有）

  ![1534251417274](C:\Users\AbnerLi\AppData\Local\Temp\1534251417274.png)

  - 现在没有访问过的对象是被认为是不可触及的，将会被垃圾清除机制清除

  ![1534251461555](C:\Users\AbnerLi\AppData\Local\Temp\1534251461555.png)

  至此垃圾回收机制工作原理就ok了

#### 垃圾回收机制的优化算法

JavaScript 引擎在不影响执行的情况下做了很多优化，使这个过程更垃圾回收效率更高，其中就包括有：

- **分代收集**：对象会被分为“新生代”和“老生代”。很多对象完成任务后很快就不再需要了，所以对于他们的清理可以很频繁。而在清理中留下的称为“老生代”一员。 
- **增量收集** ： 如果对象很多，很难一次标记完所有对象，这个过程甚至对程序执行产生了明显的延迟。所以引擎会尝试把这个操作分割成多份，每次执行一份。这样做要记录额外的数据，但是可以有效降低延迟对用户体验的影响。 
- **闲时收集** ：垃圾回收器尽量只在 CPU 空闲时运行，减少对程序执行的影响。 

当然不限与这个，不同的引擎都有不同的实现。

#### V8引擎中的垃圾回收机制

[参考文章](https://segmentfault.com/a/1190000000440270)

（1）V8引擎的内存大小受限

就Node而言，和其它语言不同的特性中，就有其限制了JavaScript所能使用的内存（64位为1.4GB，32位为0.7GB），这也就意味着将无法直接操作一些大内存对象，很少有其它语言限制内存。

（2）为何限制（v8垃圾回收阻塞javascript的运行）

简单的看就是是V8最初是作为浏览器的JavaScript引擎而设计，不太可能遇到大量内存的场景，而深层次的原因则是由于V8的垃圾回收机制的限制。 **由于V8需要保证JavaScript应用逻辑与垃圾回收器所看到的不一样，V8在执行垃圾回收时会阻塞JavaScript应用逻辑，直到垃圾回收结束再重新执行JavaScript应用逻辑，这种行为被称为“全停顿”（stop-the-world）。**若V8的堆内存为1.5GB，V8做一次小的垃圾回收需要50ms以上，做一次**非增量式**的垃圾回收甚至要1秒以上。这样浏览器将在1s内失去对用户的响应，造成假死现象。如果有动画效果的话，动画的展现也将显著受到影响 

