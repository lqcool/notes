## 前端性能优化篇

首先附上连接：yahoo的优化原则=》https://developer.yahoo.com/performance/rules.html?guccounter=1

### 前端性能优化策略图（图片源自网络）

![前端性能优化策略](https://github.com/LQ55/notes/blob/master/%E4%BB%93%E5%BA%93%E5%9B%BE%E5%BA%93/37.png)

### 时间都去了哪里？

> **浏览器缓存为空** ：当我们首次浏览一个页面的时候，真正的对于html文档的请求占用总请求的时间一小部分。<u>其余大部分时间是用于下载其余的所有组件（图片、脚本、样式表、Flash等等）</u>，<u>用户的大部分时间也是用于等待组件的下载</u>。
>
> **浏览器缓存不为空** ：如果是第二次浏览该页面，html文档下载时间占比相对来说上升了，因为总的下载时间减少了（由于部分组件得到了缓存的原因，因此不需要再进行下载）。<u>但是大多数时间还是花在了下载组件上面</u>。 	

### 为啥需要前端性能优化

> - 第一，如果我们可以将 <u>后端响应时间缩短一半，整体响应时间只能减少5%~10%</u>，如果关注<u>前端性能，同样将响应时间减少一半，整体响应时间可以减少40%~45%</u>。
> - 通过前端通常只需要较少的时间和资源。减少后端延迟需要大改动，而前端不需要。
> - 前端性能调整已经被证明是可行的，Yahoo!中的团队通过最佳实践降低了响应时间，幅度通常为25%或者更高。

### 性能黄金法则

> 只有10%~20%的最终用户响应时间花在了下载HTML文档商，其余80%~90%时间花在了下载页面的所有组件上。

### 优化方案

#### 方案一：减少HTTP请求（图片地图、CSS Sprites、内联图片和脚本、样式表合并）

> 根据前面的分析大约80%~90%的时间都是花在了组件的下载上面，因此可以减少组件的数量。但是这个又会和产品设计和引发性能问题相互矛盾。（图片地图、CSS Sprites、内联图片和脚本、样式表合并）这些可以解决这个矛盾。
>
> **1、图片地图：**
>
> 解释：图片地图允许你在一个图片上面关联多个URL，目标URL的选择取决于用户点击了图片的那个位置。（<u>当然可以对每一个链接使用单独的一张图片，但是这样会引发多个http请求，因此使用图片地图只会引发一次http请求，响应时间会降低，减少了HTTP的开销</u> ）。
>
> 实例：[一个无图片地图的连接](http://stevesouders.com/hpws/imagemap-no.php) 
>
> ![38](https://github.com/LQ55/notes/blob/master/%E4%BB%93%E5%BA%93%E5%9B%BE%E5%BA%93/38.png)
>
> 实例：[一个有图片地图的连接](http://stevesouders.com/hpws/imagemap.php)
>
> ![39](https://github.com/LQ55/notes/blob/master/%E4%BB%93%E5%BA%93%E5%9B%BE%E5%BA%93/39.png)
>
> 通过比较上述两个页面的加载时间，发现第二个明显时间小于第一个
>
> **图片地图包括了服务器端图片地图和客户端图片地图**：
>
> - 服务器端图片地图：将所有的点击提交到同一个URL，向其传递用户点击的x和y坐标，Web服务器将x和y坐标映射为合适的操作。
> - 客户端图片地图（更适用）：将用户的点击映射到一个操作，无需向后端应用程序发送请求，映射通过HTML的MAP标签实现。
>
> **图片地图的缺点：** 
>
> 定义图片上面的坐标，如果采用手动方式，很难完成并且容易出错。而且除了矩形之外无法定义其它的形状。
>
> 
>
> **2、CSS Sprites：**
>
> 和图片地图一样，CSS Sprites也可以合并图片，但是更为灵活。CSS Sprites是将多个图片合并到一个图片中，CSS Sprites适用于任何支持背景图片的HTML标签中。通过使用CSS的background-position属性可以将元素放置到图片中期望的位置上面。
>
> ```html
> <style>
>     #div1{
>         background-image:url('sxs.gif');
>         background-position:-260px -90px;
>         width:26px;
>         height:24px;
>     }
> </style>
> <div id="div1"></div>
> ```
>
> 实例：[一个CSS Sprites的实例](http://stevesouders.com/examples/sprites.php)
>
> 图片地图要求图中的图片必须是连续的，而CSS Sprites没有这个限制。通过合并图片减少了HTTP的请求，并且比图片地图灵活。此外它还降低了下载量，很多人认为合并后的图片比原来的分开的所有图片总和要大，实际上，合并后的图片比分离的图片的总和要小，因为降低了图片自身的开销（颜色表、格式信息等等）
>
> 
>
> **3、内联图片：**
>
> 通过使用data:URL模式可以在Web页面包含图片但无需任何额外的HTTP请求。data:URL模式在1995年提议的，对它描述为：<u>允许将小块数据内联为‘立即数’，</u><u>数据就在URL自身中</u>。其它类似的模式包括：ftp:、file:和mailto:。除此之外还有很多模式，smtp:、pop:、dns:等等。
>
> 格式：data:\[\<mediatype\>\]\[;base64\]，\<data\>
>
> ```html
> <img alt="ddd" src="data:image/gif;base64,R0DHLNCGELNNBXHD476DFS.....DDSGDSDS="/>
> ```
>
> 实例：[一个内联图片的实例](http://stevesouders.com/examples/inline-images.php)
>
> 
>
> **4、合并脚本和样式表**

### 方案二：使用内容发布网络（CDN加速）

> 如果应用程序Web服务器离用户更近，则一个HTTP请求的响应时间将会缩短。另一方面，如果组件Web服务器离用户更近，则多个HTTP请求响应时间将会缩短。 <u>与其重新设计应用程序这一艰巨任务，一遍将应用程序Web服务器分散开，不如先将组件Web服务器分散开，这不仅仅能达到响应时间大幅减少的目的，还很容易实现。</u>
>
> **内容发布网络（CDN）：**
>
> 内容发布网络（CDN）是一组分布在不同地理位置的Web服务器，用于更加有效的向用户发布内容。他还能节约成本。<u>向特定用户发布内容的服务器选择基于对网络的可用度测量，例如CDN可能选择网络阶跃数最小的服务器，或者具有最短响应时间的服务器</u>。

### 方案三：添加Expires头

> 浏览器（和代理）使用缓存来减少HTTP请求的数量，并减小HTTP响应的大小，使得Web服务器页面加载更快。
>
> **Expires头：**
>
> <u>Web服务器使用Expires头告诉客户端它可以使用一个组件的当前副本</u>，直到指定日期为止。（在这以日期之后，响应应将被认为是无效的）
>
> ```properties
> #响应头中的信息，这是一个有效期非常长久的Expires头，告诉浏览器有效期持续到2014年4月15日
> Expries:Mon，15 Apr 2024 20:00:00 GTM
> ```
>
> **Expires的限制：**
>
> <u>Expires头使用一个特定的时间，他要求服务器和客户端的时钟严格同步，另外，过期日期经常检查，并且一旦这一天到来了，还需要在服务器配置中提供一个新的日期</u>。
>
> <u>HTTP1.1引入了Cache-Control头来客服Expries头的限制</u>。以秒为单位指定更新窗口。如果组件被请求开始过去的秒数少于max-age，浏览器就使用缓存信息。
>
> 可以同时指定Expires和Cache-Control:max-age，<u>两个同时出现，规范指定max-age指令将会重写Expires头</u>
>
> ```properties
> #同时使用
> Expries:Mon，15 Apr 2024 20:00:00 GTM,
> Cache-Control:max-age=3150000
> ```
>
> 长久的Expires头应该包含任何不经常变化的组件，包括图片、脚本、样式表和Flash组件等，HTML文档不应当使用长久的Expires头，因为可能包含动态内容，每次用户请求都会被更新。

### 方案四：压缩组件（使用gzip编码压缩HTTP响应包）

> 通过减小HTTP响应的大小来减少响应时间，如果HTTP请求响应包很小，传输时间就会减少。
>
> 使用gzip编码压缩HTTP响应包是最简单的减小页面大小的技术，但是影响最大。（删除注释、缩短URL等都可以减小响应包，但是收效圣微）。
>
> <u>客户端通过HTTP请求的Accept-Encoding表示对压缩的支持，Web服务器看到这个请求头，就会使用其中的一种方法来压缩响应，通过Content-Encoding头通知客户端。压缩通常能够将相应的数据量减少70%。</u>
>
> ```properties
> #请求头
> Accept-Encoding:gzip,defate
> #响应头
> Content-Encoding:gzip
> ```
>
> **Vary响应头**
>
> 问题描述：如果一个不支持gzip压缩的浏览器发送第一个请求到代理服务器，代理服务器请求下来的东西没有经过压缩而缓存，这个时候，又有一个支持gzip的浏览器发送了一个相同的请求到代理服务器，代理服务器会使用他的缓存内容，就失去了进行压缩的机会。
>
> 解决方法：在Web服务器的响应中添加Vary头，Web服务器告诉代理根据一个或者多个请求头来缓存响应。由于压缩取决于Accept-Encoding请求头，因此需要在服务器的Vary响应头中包含Accept-Encoding
>
> ```properties
> Vary:Accept-Encoding
> ```
>
> 这样使得代理缓存响应多个版本，为Accept-Encoding请求头的每一个值缓存一份。
>
> 使用下面的方式可以禁止代理服务器缓存
>
> ```properties
> Vary:*
> #或者
> Cache-Control:private
> ```
>
> 因此对于Web服务器的简单配置，压缩尽可能多的组件，就能显著改善页面的反应速度。

### 方案五：将样式表放在顶部

> 将样式表放于文档底部会导致在浏览器中阻止内容逐步呈现。为了避免当样式变化时重绘页面的元素，浏览器会阻止内容的逐步呈现，也就出现了**白屏** 。白屏是对无样式内容闪烁的弥补，浏览器可以延迟呈现，知道所有的样式表都下载完成后。
>
> <u>规则五对于加载页面实际时间没有太多的影响，影响的是浏览器对这些组件的顺序的反应。</u>

### 方案六：将脚本放在底部

> 前面使用样式表的时候，页面逐步呈现会阻止，因此建议将样式表置于HEAD中，使用脚本时，脚本会阻止并行下载，脚本后面的内容，逐步呈现都被阻塞了，后面的组件下载都被阻塞了，将脚本放在页面越靠下的地方，意味着越多的内容能够逐步的呈现。
>
> 对页面响应时间影响最大的是，页面组件的数量。HTTP1.1规范建议浏览器从每个主机名并行下载两个组件。因此如果将组件平均放到两个主机中，将会减少一般的时间。
>
> 并行下载的优点是很明显的，但是，对于脚本的下载，并行下载实际上是被禁止的，即使用了不同的主机名。

摘自《摘自高性能网站建设指南》