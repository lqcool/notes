Set

 ***特性***

 - es6中set类似数组，成员值是唯一的，`Array.from`方法可以将 Set 结构转为数组
 - Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化
 - 一种去除数组重复成员的方法：[...new Set(array)]
 - Set 加入值的时候，不会发生类型转换，Set 内部判断两个值是否不同，它类似于精确相等运算符（`===`），主要的区别是`NaN`等于自身，而精确相等运算符认为`NaN`不等于自身
 - 另外，两个对象总是不相等的：set.add({}); set.add({}); set.size // 2

  ***实例的属性和方法***

 属性：

 - `Set.prototype.constructor`：构造函数，默认就是`Set`函数
 - `Set.prototype.size`：返回`Set`实例的成员总数

 方法（操作方法）：

 - `add(value)`：添加某个值，返回 Set 结构本身
 - `delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功
 - `has(value)`：返回一个布尔值，表示该值是否为`Set`的成员
 - `clear()`：清除所有成员，没有返回值

 方法（遍历方法）：

 - `keys()`：返回键名的遍历器
 - `values()`：返回键值的遍历器
 - `entries()`：返回键值对的遍历器
 - `forEach()`：使用回调函数遍历每个成员

 Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的`values`方法，意味着，可以省略`values`方法，直接用`for...of`循环遍历 Set

 **WeakSet**

 WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。

 首先，WeakSet 的成员只能是对象，而不能是其他类型的值。

 WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。WeakSet 里面的引用，都不计入垃圾回收机制。

Map

 ***特性***

 - 作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组new Map([  ['name', '张三'],  ['title', 'Author']])
 - 不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作`Map`构造函数的参数
 - 同一个键多次赋值，后面的值将覆盖前面的值，读取一个未知的键，则返回`undefined`
 - 只有对同一个对象的引用，Map 结构才将其视为同一个键
 - 只要两个值严格相等，Map 将其视为一个键，虽然`NaN`不严格相等于自身，但 Map 将其视为同一个键

 ***实例的属性和方法***

 - `size`属性返回 Map 结构的成员总数
 - `set`方法设置键名`key`对应的键值为`value`，然后返回整个 Map 结构
 - `get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`
 - `has`方法返回一个布尔值，表示某个键是否在当前 Map 对象之中
 - `delete`方法删除某个键，返回`true`。如果删除失败，返回`false`
 - `clear`方法清除所有成员，没有返回值
 - `keys()`：返回键名的遍历器
 - `values()`：返回键值的遍历器
 - `entries()`：返回所有成员的遍历器
 - `forEach()`：遍历 Map 的所有成员

 Map 还有一个`forEach`方法，与数组的`forEach`方法类似，也可以实现遍历

 需要特别注意的是，Map 的遍历顺序就是插入顺序。Map 结构转为数组结构，比较快速的方法是使用扩展运算符。

 如果所有 Map 的键都是字符串，它可以无损地转为对象

 WeakMap

 `WeakMap`只接受对象作为键名（`null`除外），不接受其他类型的值作为键名,`WeakMap`的键名所指向的对象，不计入垃圾回收机制



