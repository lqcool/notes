### 字符串

新增的特性：

（1）`codePointAt()：`（能返回Unicode码点大于0xFFFF的字符的编码）;

（2）`为字符串添加了遍历器接口：`（for....of循环）;

（3）`includes(str,index)：`（是否包含某个字符串，接收一个开始位置）;

（4）`startsWidth(str,index)：`（是否以某个字符串开始，接收开始位置）;

（5）`endsWith(str,index)`：（是否以某个字符串结束，接收结束位置，相当于这里是针对前index个元素）;

（6）`repeat(times)：`（返回一个新的字符串，表示将元字符串重复times次）;

（7）`padStart(len,str)`和`padEnd(len,str)`：（ES2017新增的字符串自动补全功能，如果字符串长度不大于等于len，那么这两个方法会使用后面的参数str来进行补全，当然如果后面的参数加上字符串本身长度大于了len，后面的参数str多余部分会被截掉，如果不传第二个参数，将会使用`空格`进行补全）

（8）`模板字符串`，\`\`模板字符串中所有的空格和缩进都会保留在其中，模板字符串中可以嵌入变量采用`${properName}`的方式，如下

```js
var name = "bos"
var templateStr = `What the fuck you do? ${name}`
//{}里面可以包含任意的javascript表达式，可以是对象的属性如person.name或者数学表达式x+y等等，还能够调用函数${fn()}
```

（9）`模板标签`，就是在函数后面跟一个模板字符串，该函数将被用来处理跟在他后面的模板字符串，这个字符串将会作为函数的参数。如果模板字符串中有变量，就不再是简单的调用了，而是要将模板字符串先处理成多个参数，再调用函数。函数的第一个参数是数组，该数组的成员是模板字符串中那些没有被变量替换的部分，也就是变量替换只会发生在数组成员的第一个和第二个之间，第二个和第三个之间.......，后面的每一个参数都是模板字符串需要替换的值，也就是计算后的值，这里可以使用rest接收如`...rest`（详情可以查看ES6标准入门的P63）

（10）`raw()`:String.raw`HI\n ${2+3} `返回一个反斜杠都被转义的字符串。

### Set

 ***特性***

 - es6中set类似数组，成员值是唯一的，`Array.from`方法可以将 Set 结构转为数组
 - Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化
 - 一种去除数组重复成员的方法：[...new Set(array)]
 - Set 加入值的时候，不会发生类型转换，Set 内部判断两个值是否不同，它类似于精确相等运算符（`===`），主要的区别是`NaN`等于自身，而精确相等运算符认为`NaN`不等于自身
 - 另外，两个对象总是不相等的：set.add({}); set.add({}); set.size // 2

  ***实例的属性和方法***

 属性：

 - `Set.prototype.constructor`：构造函数，默认就是`Set`函数
 - `Set.prototype.size`：返回`Set`实例的成员总数

 方法（操作方法）：

 - `add(value)`：添加某个值，返回 Set 结构本身
 - `delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功
 - `has(value)`：返回一个布尔值，表示该值是否为`Set`的成员
 - `clear()`：清除所有成员，没有返回值

 方法（遍历方法）：

 - `keys()`：返回键名的遍历器
 - `values()`：返回键值的遍历器
 - `entries()`：返回键值对的遍历器
 - `forEach()`：使用回调函数遍历每个成员

 Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的`values`方法，意味着，可以省略`values`方法，直接用`for...of`循环遍历 Set

 **WeakSet**

 WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。

 首先，WeakSet 的成员只能是对象，而不能是其他类型的值。

 WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。WeakSet 里面的引用，都不计入垃圾回收机制。

Map

 ***特性***

 - 作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组new Map([  ['name', '张三'],  ['title', 'Author']])
 - 不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作`Map`构造函数的参数
 - 同一个键多次赋值，后面的值将覆盖前面的值，读取一个未知的键，则返回`undefined`
 - 只有对同一个对象的引用，Map 结构才将其视为同一个键
 - 只要两个值严格相等，Map 将其视为一个键，虽然`NaN`不严格相等于自身，但 Map 将其视为同一个键

 ***实例的属性和方法***

 - `size`属性返回 Map 结构的成员总数
 - `set`方法设置键名`key`对应的键值为`value`，然后返回整个 Map 结构
 - `get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`
 - `has`方法返回一个布尔值，表示某个键是否在当前 Map 对象之中
 - `delete`方法删除某个键，返回`true`。如果删除失败，返回`false`
 - `clear`方法清除所有成员，没有返回值
 - `keys()`：返回键名的遍历器
 - `values()`：返回键值的遍历器
 - `entries()`：返回所有成员的遍历器
 - `forEach()`：遍历 Map 的所有成员

 Map 还有一个`forEach`方法，与数组的`forEach`方法类似，也可以实现遍历

 需要特别注意的是，Map 的遍历顺序就是插入顺序。Map 结构转为数组结构，比较快速的方法是使用扩展运算符。

 如果所有 Map 的键都是字符串，它可以无损地转为对象

 WeakMap

 `WeakMap`只接受对象作为键名（`null`除外），不接受其他类型的值作为键名,`WeakMap`的键名所指向的对象，不计入垃圾回收机制



