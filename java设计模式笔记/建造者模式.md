## 建造者模式

> 是最复杂的创建型模式，将客户端与包含多个组成部分的复杂对象的创建过程分离，客户端无需知道复杂对象内部的组成部分和装配方式，只需要知道创建者的类型。

### 模式动机和定义

> 用于创建一个包含多个组成部分的复杂对象，可以返回一个完整的产品对象给用户。
>
> 定义：将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。

### 模式结构与分析

> 建造者模式包含角色：
>
> - Builder(抽象建造者)：该接口（抽象类）中一般包含两类方法，**buildPartX()**用于创建对象的各个部件，**getResult()**用于返回被创建的复杂对象。
> - ConcreteBuilder(具体建造者)：实现各个部件的构造和装配方法，定义并明确它所创建的对象，也可以提供一个方法返回创建好的复杂产品对象。
> - Product(产品角色)：包含许多部件的复杂对象。
> - Director(指挥者)：又叫导演类，复杂安排复杂对象的建造次序，与建造者类存在关联关系，可以在其constuct()建造方法中调用建造者对象的部件构造与装配方法。完成复杂对象的构建。指挥者类主要的方法有两个，第一是隔离了客户端与生产过程，第二负责控制产品的生产流程。指挥者类针对建造者编程，客户端只需要知道具体的建造者类型，就可以通过指挥者类调用建造者类的相关方法返回一个完整的对象。
>
> 模式结构图：
>
> ![23](https://github.com/lqcool/notes/blob/master/%E4%BB%93%E5%BA%93%E5%9B%BE%E5%BA%93/23.png)
>
> 实例：KFC套餐类图：
>
> 套餐是一个复杂对象，一般包含主食（如汉堡、鸡肉卷）和饮料（如可乐、果汁）等组成，不同的套餐拥有不同的组成部分，而KFC的服务员（指挥者）可以根据顾客要求，一步一步的装配这些组成部分，构造一份完整的套餐，然后返回给客户。
>
> ![24](https://github.com/lqcool/notes/blob/master/%E4%BB%93%E5%BA%93%E5%9B%BE%E5%BA%93/24.png)

### 建造者模式的优缺点

> 优点：
>
> - 客户端不必知道产品内部的组成的细节，将产品本身和创建解耦，使得相同的创建过程可以有不同的产品对象
> - 每一个具体的建造者都相对独立，与其他建造者无关，因此可以方便的增加新的具体建造者，用户使用不同的建造者就会得到不同的产品对象。
> - 可以更加精细的控制产品的创建过程。将复杂的创建步骤分解在不同的方法中，使得创建过更加清晰，也方便使用程序来控制创建过程（例如导演者可以控制创建产品内部的组成顺序）
> - 符合开闭原则，增加新的创建者不需要修改原有代码
>
> 缺点：
>
> - 建造者模式创建的产品多半具有**较多的共同点**，产品差异很大，不适合创建者模式
> - 如果产品内部比较复杂，可能会导致需要定义更多具体建造者来实现这种变化，导致系统变得庞大

JavaMail就是用了建造者模式

### 建造者模式的扩展

> 建造者模式的简化：
>
> - 省略抽象建造者角色：如果系统只需要一个建造者的话
> - 省略指挥者角色：在具体建造者只有一个的情况下，如果抽象建造者已经被省略，也可以省略掉指挥者，让builder扮演指挥者和建造者双重角色。

### 建造者模式和抽象工厂模式的比较

> 抽象工厂模式：
>
> - 返回一系列的产品
> - 这些产品位于不同的产品等级结构，它们构成了一个产品族
> - 客户端实例化工厂类，然后调用工厂方法
>
> 建造者模式：
>
> - 返回一个组装完成的产品
> - 客户端（可以）不直接调用建造者的相关方法，通过指挥者类生成对象。侧重于一步一步的建造一个完整对象。
>
> **如果将工厂模式看作汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一个完整的汽车**。
