### 面向对象中的设计原则

常用的面向对象设计原则包括如下：

#### 单一职责原则

> ​ 一个类只负责一个功能领域中的相应的职责，或者可以定义为，就一个类而言，只应该有一个引起它变化的原因。
>
>  单一职责原则是实现高内聚，低耦合的指导方针，是最简单又最难以运用的原则。

#### 开闭原则

> 软件实体对于扩展开放，对于修改是关闭的（软件实体应该尽量在不修改原有代码的基础上面进行扩展）。实现开闭原则的关键是抽象化，并且从抽象话导出具体实现，开闭原则通常是在原有模块中添加抽象层（如接口、抽象类等等）。

#### 里氏代换原则

> 一个软件实体如果使用的是一个基类对象的话，那么一定适用于其子类对象，而且察觉不出基类对象和子类对象的区别，即把基类对象替换成子类对象，程序不会出错。反过来就不一定成立，如果一个软件实体使用的是子类对象，那么不一定适用于基类对象。
>
> 运用里氏代换原则的时候，尽量将一些需要扩展的类或者存在变化的类设计为抽象类或者接口，并将其作为基类对象，在程序中尽量针对基类对象进行编程。
>
> 由于子类继承基类并覆盖基类的方法，在程序运行的时候，子类对象可以替换基类对象，如果需要对子类的行为进行修改，可以通过扩展基类来增加新的子类，而无需修改使用该基类对象的代码。

#### 依赖倒转原则

> 抽象类不应该依赖于细节，细节应当依赖于抽象类。（要正对接口编程，而不是正对实现编程）。
>
> 在程序代码中传递参数或者在关联关系中，尽量使用高层的抽象类。（通过接口和抽象类进行变量的声明，参数类型声明，方法返回类型的声明，数据类型的转换等，不要使用具体的类型来做这些事情）。
>
> 如果说开闭原则是面向对象的主要设计目标的话，依赖倒转原则就是面向对象的主要机制。

#### 接口隔离原则

> 使用多个专门的接口，而不使用单一的总接口。每个接口应该承担一种相对独立的角色，不多不少，不干不该干的事情。

#### 合成复用原则

> 又叫组合/聚合复用原则
>
> 尽量使用对象组合，而不是用继承来达到复用的目的。合成复用原则就是在一个新的对象里面通过关联关系（包括组合、聚合）来使用一些已有的对象，使之成为新的对象的一部分。新对象通过委派调用对象的方法达到复用的目的。（复用时要尽量使用组合、聚合关系（关联关系），少用继承，降低类与类之间的耦合度）
>
> 继承复用（白箱复用）：主要的问题是破坏系统的封装性，将基类的实现细节都暴露给了子类，基类改变，子类的实现不得不改变，从基类继承而来的实现是静态的，不可能在运行的时候发生改变，没有足够的灵活性。
>
> 组合、聚合复用（黑箱复用）：将已有对象纳入到新对象中，成为新对象的一部分，新对象可以调用已有对象对的功能。使得成员对象内部的实现细节对于新对象来说是不可见的。耦合度低，成员对象的变化对新对象的影响不大，可以在新对象中根据需要有选择性的调用成员对象的操作。
>
>  ***两个类之间是Has-A关系应该使用组合或聚合，如果是Is-A关系使用继承。*** Is-A：一个类是另外一个类的一种，Has-A表示某一个角色具有某一项职责。

#### 迪米特法则

> 指一个软件实体应当尽可能少的与其他实体发生相互作用，这样当一个模块修改时，就会尽量少的影响其它模块，扩展会相对较为容易。
>
> 广义的迪米特法则：如果两个类之间不彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。
>
> 狭义的迪米特法则：可以降低类之间的耦合，但是会在系统中增加大量方法散落在系统的各个角落中。
>
> 迪米特法则主要用途在于控制信息的过载。使用时应该注意几点：
>
> - 类的划分上，尽量划分松耦合的类，耦合度越低，越利于复用，松耦合的类被修改，不会对关联类造成太大的波动。
> - 类的结构设计上：每一个类都应当尽量降低其成员变量和成员函数的访问权限。
> - 类的设计上：只要有可能，一个类型应当设计成为一个不变类。
> - 对其他类的引用上：一个对象对其他类的引用应该尽量降到最低。

